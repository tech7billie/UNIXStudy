# UNIX_2 문제 풀이

1. **수정된지 100일이 지난 파일 목록 출력 (명령어 : find)**

    find : 특정 기간에 작성, 변경된 파일 목록을 조회하고 싶을 때.

    파일명의 날짜가 아니라 파일의 타임스탬프로 파일을 검색한다.

```bash
find -mtime +100 -type f -ls
# 찾는다 수정된지 100일 이상된 파일 목록 
```

- -mtime 부호 의미

[UNIX_2%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%B5%20b939fe092c8b4ad6a695853e13b65171/mtime.jfif](UNIX_2%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%B5%20b939fe092c8b4ad6a695853e13b65171/mtime.jfif)

**2. 명령어 (ll)**

```bash
ll -rt 
# ll : ls -al 의 alias 이다. 
# -a : 숨김파일까지 모두 보인다
# -l : 리스트로 보여준다.

# -r : 내림차순 정렬 
# -t : 시간 순 정렬 
```

**3. 명령어가 저장되는 history 파일의 경로** 

 home 디렉토리의 .bash_history 파일에 명령어가 저장된다. 

**4. 저장된 히스토리를 파일명 'myhistory.log' 로 저장** 

```bash
$ history -w myhistory.log
```

**5. 아래 디렉토리의 소유자/그룹을 하위 디렉토리, 파일까지 전부 nobody 로 변경하시오.** 

**(명령어 :chown)**

```bash
$ chown [OPTIONS] USER[:GROUP] FILE(s)

$ chown -R nobody:nobody ./*
# 소유자 변경, 하위소유자 모두 변경, 유저:그룹 파일전부
```

**6. temp 디렉토리의 파일 중, 하루가 지난 파일을 삭제하시오. (명령어:find)**

```bash
# 형식
#find [경로] [옵션] [옵션조건]...

$ find ~/temp -ctime +1 -type f -exec rm -f {} \;
# 찾는다 경로 하루가 지난 파일을 / 명령어를 적용 파일 삭제 
```

- 리눅스 atime mtime ctime 시각 표시 방법

    atime : 마지막으로 파일에 **접근**한 시각 (access)

    mtime : 마지막으로 파일이 **수정**된 시각 (modify) 

    → 내용 추가, 파일 사이즈 변경 등 파일 데이터가 변경될 때

    ctime : 마지막으로 파일이 **변경**된 시각 (change) 

    → 파일의 권한이나 속성, 크기나 링크 정보 등이 해당 (inode 정보 변경) 

    ex) chown, chmod 등을 사용했을 때 

- find 의 type 옵션의 인수

    d: 디렉토리

    f : 일반 파일 

    l : 심볼릭 링크 

    p : 파이프

    s : 소켓

- -exec 옵션 : find 명령어로 찾은 결과 대상에 대해 원하는 명령어를 적용시킬 수 있게 해준다.

    ```bash
    # 형식 
    -exec 명령어{} \;
    # {} : find 로 찾은 파일들
    # \; : -exec 옵션 내용의 끝을 나타냄 
    ```

**7. screen 명령어를 사용하여, 서버와의 연결이 비정상 종료되더라도, session 은 유지한 채 작업을 할 수 있다. 이때 단축키를 사용하여 screen 에서 빠져나오시오.**

```bash
CTRL + a + d 
```

**8. 자신이 사용하고 있는 tty 를 출력하시오.**

```bash
$ tty

#출력 결과 --==>> /dev/pts/0
```

- tty(teletypewriter) : 일반 CLI 콘솔

    pts : 기본 xwindows. 를 위한 가상 콘솔 

**9. 아래 그림과 같이 단계적인 디렉토리를 한번에 생성하시오.**

mkdir의 -p(parent) 옵션을 사용하면 부모 디렉토리까지 한번에 생성할 수 있다.

`$ mkdir -p ./1/2/3/4`

**10. grep 명령어의 위치를 출력하시오.**

- grep : 입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자 할 때 사용하는 명령어

```bash
$ which grep
/bin/grep

$ whereis grep
grep: /bin/grep /usr/share/man/man1/grep.1.gz
```

**11. 상위 디렉토리로 이동하는 'cd..' 를 'pd' 로 정의하시오(alias)**

```bash
alias pd='cd ..'
```

**12. 이전에 친 'vi mytest' 명령어를 다시 출력하는 방법은 무엇인가.**

```bash
$ vi mytest
$ !!
```

**13. 아래 출력결과를 현재 경로 내에  result.txt 파일로 저장하시오.**

```bash
ll > result.txt
```

**14. 5개의 백그라운드(background) 작업 중, 3번 작업을 포그라운드(foreground)로 가져오시오.**

```
$ jobs
[1] ~~
[2] ~~
[3] ~~
[4] ~~
[5] ~~

$ fg %3
```

 ㄴ참고 

[프로세스 관련 명령어들](https://adnoctum.tistory.com/377)

**15. 이름 'vi' 프로세스를 찾아 종료시키시오.(vi 프로세스 id 는 9140 으로 가정한다.)**

```bash
# 형식
# $ ps [option]

# 찾아서 
$ ps -ef |grep vi

# 종료 
$ kill 9140
```

- ps -ef : cpu 사용률과 사용중인 프로세스 체크

    ps : 현재 실행중인 프로세스 목록과 상태를 보여준다.

    ㄴ 참고 

    [[리눅스, 유닉스] ps 프로세스 명령어 완벽정리, 프로세스 관리, 계열에 따른 옵션 차이, 조건에 맞게 프로세스 정보 추출하기](https://jhnyang.tistory.com/268)

**16. (a) 에서 (b) 의 결과를 얻으시오(명령어:ll)**

→ 디렉토리만 출력 

```bash
$ ll -d 
```

**17. 'test.txt' 파일에서 상단 10줄을 읽어 오류만 'error.txt' 에 저장하시오.**

```bash
$ head text.txt 2> error.txt
```

- head 는 기본적으로 앞에서 10줄만 읽어오는 명령어, 반대의 경우는 tail

    ```bash
    # 형식
    # $ head [-n lines | -c bytes] [file ...]

    # 앞에서부터 20줄 출력
    $ head - 20 test 

    # 앞에서부터 200줄 출력 
    $ head -n 200 test 

    ```

- 2>는 에러 리다이렉션

    0 : 표준 입력

    1 : 표준 출력

    2 : 표준 에러 

**18. 'test.txt' 파일에 'link_test' 이름으로 심볼링 링크를 생성하시오.** 

- 심볼릭 링크 : 원본 파일을 가리키도록 링크만 연결시켜둔 것

```bash
# 형식
# $ln -s [원본파일의 이름] [심볼릭 링크 이름]
$ ln -s test.txt link_test

# ln : 하드링크 또는 심볼릭 링크 생성. 
# -s : 심볼릭 링크 생성. 옵션 없이 ln 사용하면 하드 링크가 생성된다.  
```

**19. (a) 에서 (b) 결과를 얻으시오 (명령어 : du)**

→ 폴더 내 모든 파일의 용량을 단위로 나타내시오.

```bash
$ du -ah

4.0K    ./cfile
4.0K    ./afile
4.0K    ./bfile
4.0K    ./dfile
24K .

# du : 디렉토리나 사용자별 디스크 사용량 확인 시 사용 (특정 디렉토리 별로 사용량을 알려줌)
# -h : 사용자가 보기 편한 형태의 용량으로  출력 
# -a : 모든 파일 및 디렉토리의 정보를 출력 
# -s : 지정된 디렉토리 내에 존재하는 모든 파일 및 서브 디렉토리들의 용량을 합쳐서 표시 
```

**20. 현재 디렉토리의 모든 파일에서 'mail' 이라는 패턴이 들어간 파일의 이름을 출력하라.(명령어 : grep)**

```bash
$ grep -l mail ./*

# -c: 패턴이 일치하는 행의 수를 출력
# -i: 비교시 대소문자를 구별안함
# -v: 지정한 패턴과 일치하지 않는 행만 출력
# -n: 행의 번호를 함께 출력
# -l: 패턴이 포함된 파일의 이름을 출력
# -w: 패턴이 전체 단어와 일치하는 행만 출력
```

**21. ‘m’으로 시작하는 모든 파일에서 ‘hamster’를 포함하는 모든 행을 찾으시오(명령어: grep)**

```bash
$ grep -n hamster ./m*****
```

**22. 현재 디렉토리 내의 'test.txt'파일에서 ':' 구분자를 이용하여 3번째 필드를 출력하라**

**(명령어: awk)**

```bash
# 형식
# awk [-f 프로그램파일] [-F 필드구분자] ['패턴{액션}'] [처리할 파일명]

$ awk -F: '{print $3}' ./test.txt
#  : 을 구분자로 / 세번째 필드 출력 / 현재 디렉토리의 / test.txt 에서 
```

- awk : 파일 정보, 파일 시스템 정보, 프로세스 정보 등 수많은 데이터 중에서 원하는 것을 추출 혹은 조작할 수 있게 해주는 유용한 프로그램이다.

**23. 현재 디렉토리 내의 `test.txt`파일에서 1행에서 3행까지 출력하라. (명령어: sed)**

```bash
# 형식 
# $ sed[옵션] 스크립트 입력파일1 [입력파일2 ...]
$ sed -n '1,3p' ./test.txt

# -n : 읽어들인 라인을 암시적으로 자동출력하는 것을 중단한다. 
#  p : 행을 출력한다.  
```

- sed : 스트림 에디터 , 원본 파일에 변형을 주지 않고 단지 출력되는 결과를 변화시켜 보여줌

**24. vi 에디터의 탭 간격을 4로 설정하시오(vi  에디터를 실행시켰다고 가정)**

```bash
# 탭 간격 설정 
:set sts**=**4

# 문서에 있는 '\t' 문자를 몇 칸으로 보여줄지 설정 
:set ts=4  

# >> 또는 << 키로 탭 사이즈를 조절하거나 인덴트에서 자동 줄맞추기를 할 때 사용되는 화면 표시 크기 
:set sw=4

```

**25. 다음 vi 화면에서 'if' 를 'testif' 로 한번에 변경하시오**

```bash
# 형식 

# 문서 전체에서 변경
# :%s/변경전문자/변경후문자/g       

# 1~10번줄에서 변경
:1,10s/변경전문자/변경후문자/g    

:%s/if/testif/g
```

**26. 실행중인 터미널의 사이즈를 구하시오**

```bash
$ stty size
```

- stty : 터미널의 설정을 보여주거나 설정 내용을 변경이 가능하게 해주는 명령어

**27. 로그인하고 있는 모든 사용자를 출력하시오.**

```bash
$ who
```

**28. 현재 서버의 메모리와 캐시 사용량을 mb단위로 출력하시오.**

```bash
$ free -m 

# -m : mb
# -k : kb
# -g : gb
```

**29. 현재 디렉토리에 linux.txt라는 파일을 만드는 alias를 작성하시오(alias명: linux)**

```bash
$ alias linux = 'touch linux.txt'
```

**30. 포그라운드에서 실행중인 프로세스를 일시정지 하는 단축키는 무엇인가?**

```bash
# 100초간 일시정지 (실행 중인 프로세스)
$ sleep 100 

# 일시정지하는 단축키
Ctrl + z 
```

**31. 아래 리스트에서 6자리 단어이자 대소문자 구분없이 y가 포함되는 단어의 개수를 출력하라.**

1. jbw1010
2. woogil70
3. nianelo4
4. yuneert12
5. asfsddd2
6. 12312dfd

```bash
$ more list | grep -w '......' | -ic 'y' 

# more : 파일을 읽어 화면 단위로 끊어서 출력하는 명령어
# -w : 패턴과 일치하는 단어만 출력 
# -i : 대소문자 구분 x 
# -c : 패턴이 일치하는 행의 수를 출력 
```

**32. diff -u b a명령어를 이용하여 아래와 같은 결과를 도출하였다. 결과값을 가지고 a파일을 만드시오.** 

```bash
# 형식
# $ diff [옵션] file1 file2

$ diff -u b a # 결과값 
~~~ 
$ diff -u b a > a # 결과값을 a 파일로 

# diff : 두 파일 사이의 내용을 행 단위로 비교하고 차이점을 출력해주는 명령어
# -u : unified context 옵션으로, 내용, 삭제 부분, 추가부분, 동일부분까지 종합적으로 보여줌
```

**33. 당일 오후 1시로 알람을 지정한 뒤, 프로세스를 죽이시오 (PID는 9140으로 가정한다.)**

```bash
# signal 발생 방법 
# $ kill [-signalID] PID

$ kill -14 9140 | at 13:00

# SIGALRM(signalId : 14) 
# : alarm 함수가 보내는 signal 이다. 
#   알람을 발생시키고 프로세스를 종료한다.

**#** at은 리눅스 터미널에서 간편하게 예약작업을 가능하게 해준다.
```

**34. 10G의 더미 파일을 만들고자 한다. 빈칸을 채우시오.(파일명을 mailplug) 로 지정한다.**

```bash
# 문제
$ dd if=/dev/zero _____ count=10

# 빈칸 
of=mailplug bs=1GB

# 형식
$ dd if=/dev/zero of=파일명 bs=1GB count=10

# dd는 파일을 변환하고 복사하는 명령어이다.

# $ dd if=입력 of=출력 bs=바이트 count=반복

# ibs = bytes     #한번에 bytes 바이트씩 읽는다.
# obs = bytes     #한번에 bytes 바이트씩 쓴다.
# skip = n        #n*ibs 바이트만큼 무시하고 읽는다.
# seek = n        #n*obs 바이트만큼 무시하고 쓴다.
```

**35. 시그널 이름 중 ‘SIGQUIT’은 몇 번에 해당하는가?**

→ 3번 

```bash
SIGINT(2)	프로세스 인터럽트 (Ctrl + C)
SIGQUIT(3)	프로세스 중단
SIGKILL(9)	프로세스 강제종료
SIGALRM(14)	알림 발생
SIGTERM(15)	프로세스 종료
SIGCONT(18)	프로세를 재시작하라
SIGSTOP(19)	프로세스를 일시정지
SIGTSTP(20)	프로세스 일시정지 (Ctrl + Z)
```

**36. csh에서 로그아웃 할 때 백그라운드 프로세스를 자동으로 죽이려면 어떤 파일을 참조하면 되는가?** 

→ '.logout' 파일

C쉘은 로그아웃할 때 홈디렉토리의 ‘.logout’파일을 읽는다.

**37. grep을 사용하여 마침표로 시작되는 줄을 찾으시오.**

```bash
# 형식
# $ grep '정규표현식' 파일명

$ grep '^\.' file

# ^는 파일의 시작을 나타냄. 

# '^\.' 대신 '^.' 를 사용하면 모든 줄이 출력된다.
```

**38. 디렉토리 내에서 가장 새로운 파일의 이름을 출력하는 방법은 무엇인가?(명령어: ls)**

```bash
$ ls -t1 | head -1

# ls(list) : 디렉토리에 있는 내용(이름) 확인
# -t : 시간기준 (오름차순)으로 보여준다
# -tr : 시간 기준(내림차순)으로 보여준다
# -head : 위에서 10줄 출력 
# -head -1 : 위에서부터 1줄 출력 
```

**39. 연결되지 않은 심볼릭 링크를 찾아내는 방법은 무엇인가?(명령어: find)**

```bash
$ find -L . -type l

#??
```

**40. 'rm' 명령어 사용 시, 바로 삭제시키지 않고 한번 더 물어본 후 삭제시키고자 할 때 사용하는 옵션은?**

```bash
$ rm -i file명 
```

**41. cat명령어 옵션 중 tab과 행바꿈 문자를 제외한 제어 문자를 ^형태로 출력해주는 옵션은?**

```bash
$ cat -v file명 
```

**42. 0.0.0.0에서 999.999.999.999까지 표현할 수 있는 정규식을 작성하시오.**

```bash
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}

# 정수 자리수(1자리~3자리)
```

**43. 'egrep' 명령어를 이용하여 'testfile' 내 '숫자 3이 한 번 이상 등장하는 행을 출력하시오.** 

```bash
$ egrep '3+' testfile

# egrep : grep 의 확장판. 여러개의 문자열을 동시에 찾을 수 있고, 추가 정규 표현식 메타 문자를 지원한다.

# +: +앞의 정규표현식이 1회 이상 나타남
# ?: ?앞의 정규표현식이 0회 또는 1회 나타남
# |: 문자열간의 OR연산자
# (): 정규표현식을 둘러쌈
```

**44. 디렉토리 구조는 아래와 같다. [a.py](http://a.py) 를 vi 편집기로 연 후, 빠져나오지 않은 채, [b.py](http://b.py) 로 전환하시오.**

```bash
$ vi a.py

:e b.py
```

**45. 파일의 제일 앞부분에 있는 100개의 문자를 삭제하시오. (명령어 : dd)**  

```bash
$ dd if=file of=file ibs=1 skip=100 conv=notrunc

# $ dd if=입력 of=출력 bs=바이트 count=반복

# ibs = bytes     #한번에 bytes 바이트씩 읽는다.
# obs = bytes     #한번에 bytes 바이트씩 쓴다.
# skip = n        #n*ibs 바이트만큼 무시하고 읽는다.
# seek = n        #n*obs 바이트만큼 무시하고 쓴다.

# conv : 기호 목록에 따라 파일을 변환한다.
		# notrunc : 출력 파일을 자르지 않고 출력한다.
```

한번에 1바이트씩 총 100번 즉 100개의 문자를 삭제하고 읽어와 쓴다.

**46. test.log 파일을 정렬하여, 동일 디렉토리 내 result.log에 작성하시오.**

```bash
# 형식
# sort [-옵션][-o 저장될 파일명] 정렬할 파일명 [병합할 파일명...]

$ sort -o result.log test.log

# 옵션 
# -n 라인의 각 필드를 비교하는 대상을 숫자로 한정 
# -f     영어를 정렬할 때, 대소문자 구별안함 
# -r     출력 순서를 역순으로 
# -b    앞에 붙는 공백 무시
# -t     필드 구분자 지정
# -m   정렬된 파일을 병합
# -u    정렬후, 중복행 제거
# -o    저장할 파일명을 명시, 명시하지 않으면 화면에 출력 
```

**47. 백그라운드로 실행중인 프로세스나 현재 중지된 프로세스 목록을 PID와 같이 출력하라**

```bash
$ jobs -l
```

**48. 현재 crontab에 등록된 작업을 출력하시오.**

```bash
$ crontab -l

# crontab : 특정 시간에 특정 작업을 해야한다. 윈도우의 스케줄러와 비슷 
```

**49. 아래 crontab에 대해 맞는 설명은?**

```bash
30 4,12 * * * rm /home/*.log

# → 매일 4시 30분 12시 30분에 홈디렉토리의 모든 *.log파일을 삭제해라

#    *　　　　　　*　　　　　　*　　　　　　*　　　　　　*
# 분(0-59)　　시간(0-23)　　일(1-31)　　월(1-12)　　　요일(0-7)
```

**50. vi편집기 내에서 문서 최상단으로 커서를 위치시키는 명령어는?**

→ 1G  또는 gg 

문서의 맨 마지ㄱ막으로 이동 : G
